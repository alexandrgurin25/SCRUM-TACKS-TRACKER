package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"
	"gateway/internal/domain/models"
	"gateway/internal/graphql/graph/model"
	"io"

	"github.com/AlexMickh/logger/pkg/logger"
	"github.com/AlexMickh/scrum-protos/pkg/api/comments"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.uber.org/zap"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	const op = "graphql.graph.RegisterUser"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("email", input.Email),
	)

	user, err := r.authService.Register(ctx, input.Email, input.Username, input.Password)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to register user", zap.Error(err))
		return nil, gqlerror.Errorf("failed to register user")
	}

	return &model.User{
		ID:       user.ID,
		Email:    user.Email,
		Username: user.Username,
	}, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.Login) (*model.Tokens, error) {
	const op = "graphql.graph.LoginUser"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("email", input.Username),
	)

	accessToken, refreshToken, err := r.authService.Login(ctx, input.Username, input.Password)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to login user", zap.Error(err))
		return nil, gqlerror.Errorf("failed to login user")
	}

	return &model.Tokens{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// UpdateTokens is the resolver for the updateTokens field.
func (r *mutationResolver) UpdateTokens(ctx context.Context, refreshToken string) (*model.Tokens, error) {
	const op = "graphql.graph.UpdateTokens"

	ctx = logger.GetFromCtx(ctx).With(ctx, zap.String("op", op))

	accessToken, refreshToken, err := r.authService.UpdateTokens(ctx, refreshToken)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to update tokens", zap.Error(err))
		return nil, gqlerror.Errorf("failed to update tokens")
	}

	return &model.Tokens{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.NewTask) (*model.Task, error) {
	const op = "graphql.graph.CreateTask"

	ctx = logger.GetFromCtx(ctx).With(ctx, zap.String("op", op))

	task, err := r.taskService.CreateTask(ctx, input.BoardID, input.Title, input.Description, input.Deadline)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to create task", zap.Error(err))
		return nil, gqlerror.Errorf("server error")
	}
	return &model.Task{
		ID:          task.ID,
		BoardID:     task.BoardID,
		AuthorID:    task.AuthorID,
		Title:       task.Title,
		Description: task.Description,
		Deadline:    task.Deadline,
		CreatedAt:   task.CreatedAt,
		UpdatedAt:   task.UpdatedAt,
	}, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, input model.UpdateTask) (*model.Task, error) {
	const op = "graphql.graph.UpdateTask"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", input.ID),
	)

	task, err := r.taskService.UpdateTask(
		ctx,
		input.ID,
		input.Title,
		input.Description,
		input.Deadline,
	)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to update task", zap.Error(err))
		return nil, gqlerror.Errorf("server error")
	}

	return &model.Task{
		ID:          task.ID,
		BoardID:     task.BoardID,
		AuthorID:    task.AuthorID,
		Title:       task.Title,
		Description: task.Description,
		Deadline:    task.Deadline,
		CreatedAt:   task.CreatedAt,
		UpdatedAt:   task.UpdatedAt,
	}, nil
}

// ChangeBoard is the resolver for the changeBoard field.
func (r *mutationResolver) ChangeBoard(ctx context.Context, input model.ChangeBoard) (bool, error) {
	const op = "graphql.graph.ChangeBoard"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", input.ID),
	)

	err := r.taskService.ChangeBoard(ctx, input.ID, input.BoardID)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to change board", zap.Error(err))
		return false, gqlerror.Errorf("server error")
	}

	return true, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	const op = "graphql.graph.DeleteTask"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", id),
	)

	err := r.taskService.DeleteTask(ctx, id)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to delete task", zap.Error(err))
		return false, gqlerror.Errorf("server error")
	}

	return true, nil
}

// CreateBoard is the resolver for the createBoard field.
func (r *mutationResolver) CreateBoard(ctx context.Context, input model.NewBoard) (*model.Board, error) {
	const op = "graphql.graph.CreateBoard"

	ctx = logger.GetFromCtx(ctx).With(ctx, zap.String("op", op))

	board, err := r.boardService.CreateBoard(ctx, input.ProjectID, input.Title)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to create board", zap.Error(err))
		return nil, gqlerror.Errorf("server error")
	}

	return &model.Board{
		ID:    board.ID,
		Title: board.Title,
		Tasks: copyTasks(board.Tasks),
	}, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input *model.NewProject) (string, error) {
	const op = "graphql.graph.CreateProject"

	ctx = logger.GetFromCtx(ctx).With(ctx, zap.String("op", op))

	id, err := r.projectService.CreateProject(ctx, input.Title, input.Description)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to create project", zap.Error(err))
		return "", gqlerror.Errorf("server error")
	}

	return id, nil
}

// AddParticipantToProject is the resolver for the addParticipantToProject field.
func (r *mutationResolver) AddParticipantToProject(ctx context.Context, input model.AddParticipant) (bool, error) {
	const op = "graphql.graph.AddParticipantToProject"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", input.ID),
	)

	err := r.projectService.AddParticipantToProject(ctx, input.ID, input.Email)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to add participant", zap.Error(err))
		return false, gqlerror.Errorf("server error")
	}

	return true, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	const op = "graphql.graph.DeleteProject"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", id),
	)

	err := r.projectService.DeleteProject(ctx, id)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to delete project", zap.Error(err))
		return false, gqlerror.Errorf("server error")
	}

	return true, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (string, error) {
	const op = "graphql.graph.CreateComment"

	ctx = logger.GetFromCtx(ctx).With(ctx, zap.String("op", op))

	id, err := r.commentService.CreateComment(ctx, input.TaskID, input.Title, input.Description)
	if err != nil {
		return "", fmt.Errorf("%s: %w", op, err)
	}

	return id, nil
}

// GetBoardByID is the resolver for the getBoardById field.
func (r *queryResolver) GetBoardByID(ctx context.Context, id string) (*model.Board, error) {
	const op = "graphql.graph.GetBoardID"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", id),
	)

	board, err := r.boardService.GetBoardByID(ctx, id)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to get task by id", zap.Error(err))
		return nil, gqlerror.Errorf("server error")
	}

	return &model.Board{
		ID:    board.ID,
		Title: board.Title,
		Tasks: copyTasks(board.Tasks),
	}, nil
}

// GetProject is the resolver for the getProject field.
func (r *queryResolver) GetProject(ctx context.Context, id string) (*model.Project, error) {
	const op = "graphql.graph.GetProject"

	ctx = logger.GetFromCtx(ctx).With(ctx,
		zap.String("op", op),
		zap.String("id", id),
	)

	project, err := r.projectService.GetProject(ctx, id)
	if err != nil {
		logger.GetFromCtx(ctx).Error(ctx, "failed to get project", zap.Error(err))
		return nil, gqlerror.Errorf("server error")
	}

	return &model.Project{
		ID:             project.ID,
		AuthorID:       project.AuthorID,
		ParticipantsID: project.ParticipantsID,
		Title:          project.Title,
		CreatedAt:      project.CreatedAt,
		UpdatedAt:      project.UpdatedAt,
	}, nil
}

// GetComments is the resolver for the getComments field.
func (r *subscriptionResolver) GetComments(ctx context.Context, taskID string) (<-chan *model.Comment, error) {
	const op = "graphql.graph.GetComments"
	fmt.Println("yes")

	ctx = logger.GetFromCtx(ctx).With(ctx, zap.String("op", op))

	ch := make(chan *model.Comment)

	go func() {
		defer close(ch)

		serv, err := r.commentService.GetClient().GetComments(ctx, &comments.GetCommentsRequest{
			TaskId: taskID,
		})
		if err != nil {
			fmt.Println(err)
			return
		}

		for {
			res, err := serv.Recv()
			if errors.Is(err, io.EOF) {
				return
			}
			if err != nil {
				fmt.Println(err)
				return
			}
			comm := &model.Comment{
				ID:          res.Id,
				TaskID:      taskID,
				AuthorID:    res.AuthorId,
				Title:       res.Title,
				Description: res.Description,
			}
			select {
			case <-ctx.Done():
				fmt.Println("Subscription Closed")
				return

			case ch <- comm:
			}
		}
	}()

	return ch, nil
}

func copyTasks(tasks []*models.Task) []*model.Task {
	var tasksGql []*model.Task
	for _, task := range tasks {
		taskL := &model.Task{
			ID:          task.ID,
			BoardID:     task.BoardID,
			AuthorID:    task.AuthorID,
			Title:       task.Title,
			Description: task.Description,
			Deadline:    task.Deadline,
			CreatedAt:   task.CreatedAt,
			UpdatedAt:   task.UpdatedAt,
		}
		tasksGql = append(tasksGql, taskL)
	}

	return tasksGql
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func copyTasks(tasks []*models.Task) []*model.Task {
	var tasksGql []*model.Task
	for _, task := range tasks {
		taskL := &model.Task{
			ID:          task.ID,
			BoardID:     task.BoardID,
			AuthorID:    task.AuthorID,
			Title:       task.Title,
			Description: task.Description,
			Deadline:    task.Deadline,
			CreatedAt:   task.CreatedAt,
			UpdatedAt:   task.UpdatedAt,
		}
		tasksGql = append(tasksGql, taskL)
	}

	return tasksGql
}
*/
